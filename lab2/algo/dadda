#!/usr/bin/python3

#############################################
## Eliminare i commenti per stampare tutto ##
#############################################

import sys

Npp = 5
Nbit = 11

def FA(A, B, c_in):
    s_out = int((not c_in and (not A) and B)
            or (not c_in and A and (not B))
            or (c_in and (not A) and (not B))
            or (c_in and A and B))
    c_out = int((A and B)
            or (c_in and A and (not B))
            or (c_in and B and (not A)))
    return s_out, c_out


def HA(A, B):
    s_out = int((A and (not B)) or (B and (not A)))
    c_out = int(A and B)
    return s_out, c_out


def dadda_fun(vertical_table, goal):
    empty_col = []
    if not (vertical_table[-1] == empty_col):
        vertical_table.append(empty_col)

    for i in reversed(range(len(vertical_table) - 1)):
        col = vertical_table[i]
        next_col = vertical_table[i - 1]
        if len(vertical_table[i]) > goal:
            diff = len(col) - goal
            if diff == 3:
                print("Adding an FA + HA in col", len(vertical_table)-i)

                # data
                c_in = col[0]
                A_FA = col[1]
                B_FA = col[2]
                A_HA = col[3]
                B_HA = col[4]

                # operation: FA + HA
                s_FA, c_FA = FA(A_FA, B_FA, c_in)
                s_HA, c_HA = HA(A_HA, B_HA)

                # remove used data from list
                col.remove(c_in)
                col.remove(A_FA)
                col.remove(B_FA)
                col.remove(A_HA)
                col.remove(B_HA)

                # add computed result to list
                col.append(s_FA)
                next_col.append(c_FA)
                col.append(s_HA)
                next_col.append(c_HA)

            elif diff == 2:
                print("Adding an FA in col", len(vertical_table)-i)

                # data
                c_in = col[0]
                A_FA = col[1]
                B_FA = col[2]

                # operation: FA
                s_FA, c_FA = FA(A_FA, B_FA, c_in)

                # remove used data from list
                col.remove(c_in)
                col.remove(A_FA)
                col.remove(B_FA)

                # add computed result to list
                col.append(s_FA)
                next_col.append(c_FA)

            elif diff == 1:
                print("Adding an HA in col", len(vertical_table)-i)

                # data
                A_HA = col[0]
                B_HA = col[1]

                # operation: HA
                s_HA, c_HA = HA(A_HA, B_HA)

                # remove used data from list
                col.remove(A_HA)
                col.remove(B_HA)

                # add computed result to list
                col.append(s_HA)
                next_col.append(c_HA)

                # print("Cin =", c_in, "A =", A, "B =", A, "\nS =", s, "C =", c)

    for i in range(Npp+1):
        for col in vertical_table:
            if i < len(col):
                if col[i] == 1:
                    print('1', end='')
                else:
                    print('0', end='')
            else:
                print(' ', end='')
        print()

    return vertical_table


# Binary to decimal function
def dec_to_bin(dec_num, length):
    return str(format(dec_num, f'0{length}b'))


# init values
partial_products = [[0] * Nbit for _ in range(Npp)]
signs = sys.argv[-1]
pp_dec = sys.argv

if len(pp_dec) < 6:
    print("Error: required 5 partial product")
    exit(-1)

# partial product assignment (binary)
for pp in range(len(partial_products)):
    partial_products[pp] = [int(digit) for digit in dec_to_bin(int(pp_dec[pp + 1]), 11)]
    # print("pp[", pp, "]:", partial_products[pp])

# first partial product sign extension
partial_products[0] = [int(not (signs[-1]))] + [signs[-1]] + [signs[-1]] + partial_products[0]

# partial products sign extension
for pp in range(len(partial_products) - 1):
    partial_products[pp + 1] = [1] + [signs[len(partial_products) - pp - 1]] + partial_products[pp + 1]

# tree generation, weight positions

# diagonal disposition in matrix
matrix = [['x'] * (2 * Nbit) for _ in range(Npp)]
shift = Nbit - 1
first = 0

for row in range(Npp):
    if first:
        Start = Nbit + 1
    else:
        Start = Nbit + 2
    for col in range(Start, -1, -1):
        if first:
            index = shift + col - 1
        else:
            index = shift + col - 2
        matrix[row][index] = partial_products[row][col]
    shift -= 2
    first = 1

# print('for row in matrix:\n\tprint(row)\n')
# for row in matrix:
#    print(row)

# print('\n\nVertical table\n\n')
vertical_table = [[Npp] for _ in range(2 * Nbit)]
tmp_list = [0] * Npp
for i in range(2 * Nbit):
    c = 0
    for row in matrix:
        # print(c, ') Row[', i, '] is:', row[i])
        tmp_list[c] = row[i]
        c = c + 1
    # print('Tmp list is:', tmp_list)

    # print('\n\nVertical table was:', vertical_table)
    # print('Tmp_list at cycle', i, 'is:', tmp_list)
    vertical_table[i] = tmp_list.copy()
# print('Vertical table is:', vertical_table, end='\n\n')

for col in vertical_table:
    const_len_col = len(col)
    len_col = const_len_col
    i = 0
    # print('\nCol is:', col, '\n')
    while i < len_col:
        # print('col[', const_len_col + i - len_col, '] =', col[i])
        if col[i] == 'x':
            # print('Delete col. col:', end=' ')
            del col[i]
            len_col = len_col - 1
            # print(col)
        else:
            i = i + 1
    # print('Col without x is:', col)

# print('\n', vertical_table, '\n')

for i in range(len(signs)):
    vertical_table[-(i*2)-1].append(int(signs[i]))

for i in range(Npp+1):
    for col in vertical_table:
        if i < len(col):
            if col[i] == 1:
                print('1', end='')
            else:
                print('0', end='')
        else:
            print(' ', end='')
    print()

for i in range(Npp-2):
    print("\n\nITERATION:", i)
    vertical_table = dadda_fun(vertical_table, Npp - (i+1))
    print("Goal:", Npp - (i+1))

