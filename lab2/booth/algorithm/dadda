#!/usr/bin/python3

"""
File:           dadda.py
Author:         Marco Crisolgo,
                Renato Belmonte,
                Matteo Lago,
                Simone Ruffini

Email:          s305673@studenti.polito.it
Description:    Dadda algorithm implementation,
                bits               --> 11 bits,
                partial products   --> 5
"""

import sys

Npp = 5
Nbit = 11

def FA_gen(w0, w1, w2, lev, col):
    print('FA FA' + lev + '_' + col + ' ' + '(' + w0 + ',' + w1 + ',' + w2 + ')' + ';')

# Full Adder
def FA(A, B, c_in):
    s_out = int((not c_in and (not A) and B)
                or (not c_in and A and (not B))
                or (c_in and (not A) and (not B))
                or (c_in and A and B))
    c_out = int((A and B)
                or (c_in and A and (not B))
                or (c_in and B and (not A)))
    return s_out, c_out

# Half Adder
def HA(A, B):
    s_out = int((A and (not B)) or (B and (not A)))
    c_out = int(A and B)
    return s_out, c_out


def dadda_fun(vertical_table, goal):
    empty_col = []
    if not (vertical_table[-1] == empty_col):
        vertical_table.append(empty_col)

    for i in reversed(range(len(vertical_table) - 1)):
        col = vertical_table[i]
        next_col = vertical_table[i - 1]
        if len(vertical_table[i]) > goal:
            diff = len(col) - goal
            if diff == 3:
                print("Adding an FA + HA in col", len(vertical_table) - i - 2)

                # data
                c_in = col[0]
                A_FA = col[1]
                B_FA = col[2]
                A_HA = col[3]
                B_HA = col[4]

                # operation: FA + HA
                s_FA, c_FA = FA(A_FA, B_FA, c_in)
                s_HA, c_HA = HA(A_HA, B_HA)

                # remove used data from list
                col.remove(c_in)
                col.remove(A_FA)
                col.remove(B_FA)
                col.remove(A_HA)
                col.remove(B_HA)

                # add computed result to list
                col.append(s_FA)
                next_col.append(c_FA)
                col.append(s_HA)
                next_col.append(c_HA)

            elif diff == 2:
                print("Adding an FA in col", len(vertical_table) - i - 2)

                # data
                c_in = col[0]
                A_FA = col[1]
                B_FA = col[2]

                # operation: FA
                s_FA, c_FA = FA(A_FA, B_FA, c_in)

                # remove used data from list
                col.remove(c_in)
                col.remove(A_FA)
                col.remove(B_FA)

                # add computed result to list
                col.append(s_FA)
                next_col.append(c_FA)

            elif diff == 1:
                print("Adding an HA in col", len(vertical_table) - i - 2)

                # data
                A_HA = col[0]
                B_HA = col[1]

                # operation: HA
                s_HA, c_HA = HA(A_HA, B_HA)

                # remove used data from list
                col.remove(A_HA)
                col.remove(B_HA)

                # add computed result to list
                col.append(s_HA)
                next_col.append(c_HA)

                # print("Cin =", c_in, "A =", A, "B =", A, "\nS =", s, "C =", c)

    for i in range(Npp + 1):
        for col in vertical_table:
            if i < len(col):
                if col[i] == 1:
                    print('1', end='')
                else:
                    print('0', end='')
            else:
                print(' ', end='')
        print()

    return vertical_table


# Binary to decimal function
def dec_to_bin(dec_num, length):
    return str(format(dec_num, f'0{length}b'))

# INIT VALUES

# Partial products generic
pp_gen = [[0] * Nbit for _ in range(Npp)]

# Partial products
partial_products = [[0] * Nbit for _ in range(Npp)]

# Signs generic
signs_gen = ['b9x', 'b7x', 'b5x', 'b3x', 'b1x']

# Signs
signs = (sys.argv[-1])

pp_dec = sys.argv

if len(pp_dec) < 6:
    print("Error: 5 partial product required")
    exit(-1)

# partial product generic assignment (label)
for pp in range(Npp):
    for pbit in range(Nbit):
        pp_gen[pp][pbit] = "p" + str(pp + 1) + "p" + str(Nbit - pbit - 1)

# partial product assignment (binary)
for pp in range(len(partial_products)):
    partial_products[pp] = [int(digit) for digit in dec_to_bin(int(pp_dec[pp + 1]), 11)]

# partial product generic sign extension
for pp in range(Npp):
    if pp == Npp-1:
        pp_gen[pp] = pp_gen[pp]
    if pp == Npp-2:
        pp_gen[pp] = ['!' + signs_gen[0]] + pp_gen[pp]
    elif pp == 0:
        pp_gen[0] = ['!' + signs_gen[-1]] + ['x' + signs_gen[-1]] + ['x' + signs_gen[-1]] + pp_gen[0]
    else:
        pp_gen[pp] = ['xxx1'] + ['!' + signs_gen[Npp - pp - 1]] + pp_gen[pp]

#for row in pp_gen:
#    print(row)

# first partial product sign extension
partial_products[0] = [0 if int(signs[-1]) else 1] + [int(signs[-1])] + [int(signs[-1])] + partial_products[0]

# partial products sign extension
for pp in range(Npp):
    if pp == Npp-1:
        
    if pp == len(partial_products) - 2:
        partial_products[pp + 1] = [0 if int(signs[len(partial_products) - pp - 1]) else 1] + partial_products[pp + 1]
    else:
        partial_products[pp + 1] = [1] + [0 if int(signs[len(partial_products) - pp - 1]) else 1] + partial_products[
            pp + 1]

# TREE GENERATION, WEIGHT POSITIONS

# diagonal disposition in matrix (binary)
matrix = [['x'] * (2 * (Nbit - 1)) for _ in range(Npp)]

# x x x x x x x x x x x x x x
# - x x x x x x x x x x x x x
# - x x x x x x x x x x x x x
# - x x x x x x x x x x x x x
# - - x x x x x x x x x x x x
#
# to
#
# - - - - - - x x x x x x x x x x x x x x
# - - - - - x x x x x x x x x x x x x
# - - - x x x x x x x x x x x x x
# - x x x x x x x x x x x x x
# x x x x x x x x x x x x
#

offset = Npp

for row in range(Npp):
    if row == 0:
        bits = Nbit + 3
    elif row == Npp - 1:
        bits = Nbit + 1
    else:
        bits = Nbit + 2
    for col in range(bits):
        index = offset + col + 1
        matrix[row][index] = partial_products[row][col]
    # if the next row is the last one or the second one, decrement offset by one
    if ((row + 1) == Npp - 1) or ((row + 1) == 1):
        offset -= 1
    else:
        offset -= 2

# diagonal disposition in matrix (label)
matrix_gen = [['oooo'] * (2 * (Nbit - 1)) for _ in range(Npp)]

offset = Npp
for row in range(Npp):
    if row == 0:
        bits = Nbit + 3
    elif row == Npp - 1:
        bits = Nbit + 1
    else:
        bits = Nbit + 2
    for col in range(bits):
        index = offset + col + 1
        matrix_gen[row][index] = pp_gen[row][col]
    # if the next row is the last one or the second one, decrement offset by one
    if ((row + 1) == Npp - 1) or ((row + 1) == 1):
        offset -= 1
    else:
        offset -= 2

#for row in matrix_gen:
#    print(row)

# Columns generation (binary)
vertical_table = [[Npp] for _ in range(2 * (Nbit - 1))]
tmp_list = [0] * Npp

for i in range(2 * (Nbit - 1)):
    c = 0
    for row in matrix:
        tmp_list[c] = row[i]
        c = c + 1
    vertical_table[i] = tmp_list.copy()

for col in vertical_table:
    const_len_col = len(col)
    len_col = const_len_col
    i = 0
    while i < len_col:
        if col[i] == 'x':
            del col[i]
            len_col = len_col - 1
        else:
            i = i + 1

for i in range(len(signs)):
    vertical_table[-(i * 2) - 1].append(int(signs[i]))

for i in range(Npp + 1):
    for col in vertical_table:
        if i < len(col):
            if col[i] == 1:
                print('1', end='')
            else:
                print('0', end='')
        else:
            print(' ', end='')
    print()

# Generic columns generation (label)
vt_gen = [[Npp] for _ in range(2 * (Nbit - 1))]
tmp_list_gen = [0] * Npp

for i in range(2 * (Nbit - 1)):
    c = 0
    for row in matrix_gen:
        tmp_list_gen[c] = row[i]
        c = c + 1
    vt_gen[i] = tmp_list_gen.copy()

for col in vt_gen:
    const_len_col = len(col)
    len_col = const_len_col
    i = 0
    while i < len_col:
        if col[i] == 'oooo':
            del col[i]
            len_col = len_col - 1
        else:
            i = i + 1

for i in range(len(signs_gen)):
    vt_gen[-(i * 2) - 1].append('x' + signs_gen[i])

for i in range(Npp + 1):
    for col in vt_gen:
        # This is only for graphic representation
        if i < len(col):
            print(col[i], ' ', end='')
        else:
            print('    ', ' ', end='')
    print()

for i in range(Npp - 2):
    print("\n\nITERATION:", i)
    vertical_table = dadda_fun(vertical_table, Npp - (i+1))
    vt_gen = dadda_fun(vt_gen, Npp - (i+1))
    print("Goal:", Npp - (i+1))

print("PIPPO")
res = 0
c_in = 0
n = len(vertical_table)
for i in range(n):
    if not (len(vertical_table[-i - 1]) == 0):
        a = vertical_table[-i - 1][0]
        if len(vertical_table[-i - 1]) == 1:
            b = 0
        else:
            b = vertical_table[-i - 1][1]
        s, c_in = FA(a, b, c_in)
        if i == n:
            res -= s * 2 ** (i - 1)
            print(i, ")", a, "+", b, "+", c_in, "= -", s, "* 2^", (i - 1), "=", (2 ** (i - 1)), "res =", res)
        else:
            res += s * 2 ** (i - 1)
            print(i, ")", a, "+", b, "+", c_in, "=", s, "* 2^", (i - 1), "=", (2 ** (i - 1)), "res =", res)
    #    res += (el1 + el2) << (n - 1)

print(res)
